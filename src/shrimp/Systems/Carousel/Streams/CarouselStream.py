from shrimp.IO.midi import MIDIOut
from ..Base.BaseStream import BaseCarouselStream
from typing import Dict, Any, Literal, Callable, Self, Optional
from fractions import Fraction
from ..Pattern import Pattern
from ....IO.osc import OSC
import logging
import datetime
from typing import Dict, Any


class CarouselStream(BaseCarouselStream):
    """CarouselStream"""

    def __init__(self, clock, pattern: Optional[Pattern] = None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._clock = clock
        if pattern:
            self.pattern = pattern

    def stop(self):
        """Stop the stream"""
        self.pattern = None

    def choose_backend(self, event_type: Literal["SuperDirt"]) -> Callable:
        """Choose the backend for the event"""
        callbacks = {
            "SuperDirt": self.send_superdirt_message,
        }
        if event_type not in callbacks:
            raise ValueError(f"Unknown event type: {event_type}")
        return callbacks[event_type]

    def notify_event(
        self,
        event: Dict[str, Any],
        unix_timestamp: float,
        beat_timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
        beats_per_cycle: int,
    ) -> None:
        if "m" in event:
            self.send_midi_note(event=event, beat_timestamp=beat_timestamp, delta=delta, beats_per_cycle=beats_per_cycle)
        if "s" in event:
            self.send_superdirt_message(event=event, unix_timestamp=unix_timestamp, cps=cps, cycle=cycle, delta=delta)
        if "cc" in event:
            self.send_midi_cc(event=event, beat_timestamp=beat_timestamp)
        if "pc" in event:
            self.send_midi_pc(event=event, beat_timestamp=beat_timestamp)
        if "sy" in event:
            self.send_midi_sysex(event=event, beat_timestamp=beat_timestamp)

        return

    def send_midi_sysex(
        self,
        event: Dict[str, Any],
        beat_timestamp: float,
    ):
        """Sending TimeStamped MIDI sysex messages"""
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return
        event["out"].sysex(data=event.get("sy", []), timestamp=beat_timestamp),

    def send_midi_pc(
        self,
        event: Dict[str, Any],
        beat_timestamp: float,
    ):
        """Sending timestamped MIDI program change"""
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        # Send note if backend!
        event["out"].program_change(
            program=event.get("pc", 0), channel=event.get("channel", 1), timestamp=beat_timestamp
        )

    def send_midi_cc(
        self,
        event: Dict[str, Any],
        beat_timestamp: float,
    ):
        """Sending timestamped MIDI control change"""
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        # Send note if backend!
        event["out"].control_change(
            control=event.get("cc", 60),
            value=event.get("value", 100),
            channel=event.get("channel", 1),
            timestamp=beat_timestamp,
        )

    def send_midi_note(
        self,
        event: Dict[str, Any],
        beat_timestamp: float,
        delta: float,
        beats_per_cycle: int,
    ):
        """Sending MIDI note"""
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        base_duration = delta * beats_per_cycle
        duration = base_duration * event.get("dur", 1)

        event["out"].note(
            note=event.get("m", 60),
            velocity=event.get("velocity", 100),
            channel=event.get("channel", 1),
            length=duration,
            timestamp=beat_timestamp,
        )

    def send_superdirt_message(
        self,
        event: Dict[str, Any],
        unix_timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        """TODO: refactor and put that somewhere"""
        if "out" not in event or not isinstance(event.get("out", None), OSC):
            return

        output = event.pop("out")
        try:
            msg = []
            for key, val in event.items():
                if isinstance(val, Fraction):
                    val = float(val)
                msg.append(key)
                msg.append(val)

            # This second parsing mechanism is needed to get rid
            # of the faultly messages generated by the Vortex mini
            # notation. TODO: remove when correcting the notation.
            correct_msg = []
            for m in msg:
                if isinstance(m, dict):
                    correct_msg = [
                        correct_msg,
                        *list(sum([(i, v) for (i, v) in m.items()], ())),
                    ]
                else:
                    correct_msg.append(m)

            correct_msg.extend(["cps", cps, "cycle", cycle, "delta", delta])
            if "n" in correct_msg:
                try:
                    correct_msg.remove(["s"])
                except ValueError:
                    pass
            output.send(address="/dirt/play", messages=[correct_msg], timestamp=unix_timestamp)
        except Exception as e:
            logging.log(
                logging.ERROR,
                f"Error while sending message on {output}: {correct_msg} with {unix_timestamp}",
            )
            raise e
