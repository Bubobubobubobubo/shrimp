from shrimp.IO.midi import MIDIOut
from ..Base.BaseStream import BaseCarouselStream
from typing import Dict, Any, Literal, Callable, Self, Optional
from fractions import Fraction
from ..Pattern import Pattern
from ....IO.osc import OSC
import logging
import datetime


class CarouselStream(BaseCarouselStream):
    """CarouselStream"""

    def __init__(self, clock, pattern: Optional[Pattern] = None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.clock = clock
        if pattern:
            self.pattern = pattern

    def stop(self):
        """Stop the stream"""
        self.pattern = None

    def choose_backend(self, event_type: Literal["SuperDirt"]) -> Callable:
        """Choose the backend for the event"""
        callbacks = {
            "SuperDirt": self.send_superdirt_message,
        }
        if event_type not in callbacks:
            raise ValueError(f"Unknown event type: {event_type}")
        return callbacks[event_type]

    def notify_event(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ) -> None:
        if "m" in event:
            self.send_midi_note(event, timestamp, cps, cycle, delta)
        if "s" in event:
            self.send_superdirt_message(event, timestamp, cps, cycle, delta)
        if "cc" in event:
            self.send_midi_cc(event, timestamp, cps, cycle, delta)
        if "pc" in event:
            self.send_midi_pc(event, timestamp, cps, cycle, delta)
        if "sy" in event:
            self.send_midi_sysex(event, timestamp, cps, cycle, delta)

        return

    def send_midi_sysex(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return
        event["out"].sysex(data=event.get("sy", [])),

    def send_midi_pc(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        # Send note if backend!
        event["out"].program_change(program=event.get("pc", 0), channel=event.get("channel", 1))

    def send_midi_cc(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        # Send note if backend!
        event["out"].control_change(
            control=event.get("cc", 60),
            value=event.get("value", 100),
            channel=event.get("channel", 1),
        )

    def send_midi_note(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        """Sending MIDI note"""
        # Missing MIDI backend
        if "out" not in event or not isinstance(event.get("out", None), MIDIOut):
            return

        base_duration = self.clock.beat_duration
        duration = base_duration * event.get("dur", 1)

        # Send note if backend!
        event["out"].note(
            note=event.get("m", 60),
            velocity=event.get("velocity", 100),
            channel=event.get("channel", 1),
            length=duration,
        )

    def send_superdirt_message(
        self,
        event: Dict[str, Any],
        timestamp: float,
        cps: float,
        cycle: float,
        delta: float,
    ):
        """TODO: refactor and put that somewhere"""
        if "out" not in event or not isinstance(event.get("out", None), OSC):
            return

        output = event.pop("out")
        try:
            msg = []
            for key, val in event.items():
                if isinstance(val, Fraction):
                    val = float(val)
                msg.append(key)
                msg.append(val)

            # This second parsing mechanism is needed to get rid
            # of the faultly messages generated by the Vortex mini
            # notation. TODO: remove when correcting the notation.
            correct_msg = []
            for m in msg:
                if isinstance(m, dict):
                    correct_msg = [
                        correct_msg,
                        *list(sum([(i, v) for (i, v) in m.items()], ())),
                    ]
                else:
                    correct_msg.append(m)

            correct_msg.extend(["cps", cps, "cycle", cycle, "delta", delta])
            if "n" in correct_msg:
                try:
                    correct_msg.remove(["s"])
                except ValueError:
                    pass
            # logging.log(logging.INFO, f"output_send('/dirt/play', {correct_msg}, {timestamp})")
            output.send(address="/dirt/play", messages=[correct_msg], timestamp=timestamp)
            human = datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
            logging.log(logging.INFO, human)
        except Exception as e:
            logging.log(
                logging.ERROR,
                f"Error while sending message on {output}: {correct_msg} with {timestamp}",
            )
            raise e
